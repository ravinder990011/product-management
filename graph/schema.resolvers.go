package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"github.com/jinzhu/gorm"
	"github.com/ravinder990011/product-management/internal/product"
	"strconv"

	"github.com/ravinder990011/product-management/graph/model"
)

type Resolver struct {
	ProductService product.Service
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, name string, description string, price float64, stock int) (*model.Product, error) {
	p, err := r.ProductService.CreateProduct(name, description, price, stock)
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          strconv.Itoa(int(p.ID)),
		Name:        p.Name,
		Description: p.Description,
		Price:       p.Price,
		Stock:       p.Stock,
	}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, name *string, description *string, price *float64, stock *int) (*model.Product, error) {
	pid, _ := strconv.Atoi(id)
	p, err := r.ProductService.UpdateProduct(uint(pid), derefString(name), derefString(description), derefFloat64(price), derefInt(stock))
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          strconv.Itoa(int(p.ID)),
		Name:        p.Name,
		Description: p.Description,
		Price:       p.Price,
		Stock:       p.Stock,
	}, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	pid, _ := strconv.Atoi(id)
	if err := r.ProductService.DeleteProduct(uint(pid)); err != nil {
		return false, err
	}
	return true, nil
}

// BulkUpdateProducts is the resolver for the bulkUpdateProducts field.
func (r *mutationResolver) BulkUpdateProducts(ctx context.Context, products []*model.ProductInput) (*model.BulkUpdateResponse, error) {
	var prods []*product.Product
	for _, p := range products {
		//which va
		//id, err := strconv.ParseUint(p.ID, 10, 32)
		pid, err := strconv.Atoi(p.ID)
		if err != nil {
			return nil, err // Handle the error appropriately
		}
		prods = append(prods, &product.Product{
			Model:       gorm.Model{ID: uint(pid)},
			Name:        derefString(p.Name),
			Description: derefString(p.Description),
			Price:       derefFloat64(p.Price),
			Stock:       derefInt(p.Stock),
		})
	}
	success, failedIDs, err := r.ProductService.BulkUpdateProducts(prods)
	if err != nil {
		return nil, err
	}
	var failedIDStrings []string
	for _, id := range failedIDs {
		failedIDStrings = append(failedIDStrings, strconv.Itoa(int(id)))
	}
	return &model.BulkUpdateResponse{
		Success:   success,
		FailedIds: failedIDStrings,
	}, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id *string, name *string, currency *string) (*model.Product, error) {
	var p *product.Product
	var err error
	if id != nil {
		pid, _ := strconv.Atoi(*id)
		p, err = r.ProductService.GetProductByID(uint(pid), *currency)
	} else if name != nil {
		p, err = r.ProductService.GetProductByName(*name, *currency)
	}
	if err != nil {
		return nil, err
	}
	return &model.Product{
		ID:          strconv.Itoa(int(p.ID)),
		Name:        p.Name,
		Description: p.Description,
		Price:       p.Price,
		Stock:       p.Stock,
	}, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context) ([]*model.Product, error) {
	products, err := r.ProductService.GetProducts()
	if err != nil {
		return nil, err
	}
	var result []*model.Product
	for _, p := range products {
		result = append(result, &model.Product{
			ID:          strconv.Itoa(int(p.ID)),
			Name:        p.Name,
			Description: p.Description,
			Price:       p.Price,
			Stock:       p.Stock,
		})
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// Helper functions to dereference pointers
func derefString(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

func derefFloat64(f *float64) float64 {
	if f == nil {
		return 0
	}
	return *f
}

func derefInt(i *int) int {
	if i == nil {
		return 0
	}
	return *i
}
